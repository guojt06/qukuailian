一.基础概念题
1.Solidity中view和pure函数的区别是什么？分别适用于什么场景？
 view和pure都是针对状态变量的操作，view是可以读取状态变量的值，pure是不可读取。
 如果函数上没有添加这两个关键字  那么函数即可读状态变量，又可修改状态变量。

2.简述memory、storage、calldate三种数据位置的特征及使用注意事项
 memory、storage、calldate这三个关键字分别对应的存储位置不用，
 memort是存储在缓存中、storage是存储在区块链上、calldata是方法缓存
 menort可以读写，calldata只能读

3.什么是重入攻击？如何通过代码预防重入攻击？
 定义：冲入攻击是利用回调来多次调用同一个转账函数，导致把被攻击的合约以太币用完，预防方法就是现先改变状态，
 后转账

4.msg.sender和tx.origin（orj）的区别是什么？为什么不建议用tx.origin做权限校验？
 sender和otigin的区别是otigin获取地址  永远是调用者的地址
 不建议使用origin做权限检验是因为容易被攻击合约利用 从而跳过权限校验获取合约权限
 

5.dalegatecall和call的区别?
 dalegatecall主要是将被调用的函数代码放在自己的上下文中执行，对应的状态变量变更也是自己的
 call主要是调用函数，返回函数值。他的运行上下文是对应的函数合约

6.可升级合约的执行流程是什么（user->proxy->implementation）
 首先可升级合约是采用储存和逻辑分离，用户调用代码里合约，代理合约去调用逻辑合约，最后生成结果集 返回给用户  
 其中如果想升级合约的话 只需要改变代码合约的逻辑合约的地址就可以了

7.代理合约上本身是有存储的，怎么避免跟逻辑合约上的存储产生冲突？
 因为代理合约和逻辑合约的槽位是共享的  所以会产生代理合约和逻辑合约的储存冲突
 可以用间隙存储的方法来避免存储冲突  


8.可以在逻辑合约的构造函数中初始化变量吗？ 为什么
 不可以在逻辑合约的构造函数初始化变量，构造函数是逻辑合约在初始化的时候加载，
 所以在构造函数中初始化变量会造成逻辑合约的状态变量修改了  但是代理合约的状态变量没有  违背了合约升级的设计思想

二.进阶原理题
1.基于Proxy + implementation模式的可升级合约，为什么必须保证实现合约的存储结构兼容？如果存储槽的位错位会引发什么问题？
 可以升级合约基于delegatecall实现，delegatecall会让实现合约的代码在代理合约的存储上下文中执行，存储槽位是按变量声明顺序映射的
 储存槽错位的后果，会导致代理合约存储的数据被错位解析，造成数据错乱、合约功能异常甚至资金丢失。

2.简述delegatecall的执行机制，以及它在可升级合约中的核心作用
 执行机制：delagatecall调用目标合约代码时，不切换储存上下文，只是借用逻辑合约的代码逻辑
 核心作用：在proxy+implementation模式中，代理合约通过deletagecall转发用户请求到实现合约，实现合约执行逻辑并修改代理合约的存储，
 升级是只许修改代码合约的地址，无需迁移用户数据。

3.Solidity中处理以太币转账有哪几种方式？它们的优缺点分别是什么？
 以太币转账方式有3种  
 transfer（）函数  优点：固定发送2300gsa，防止重入攻击    缺点；Gas限制固定，不适合复杂回调逻辑，转账失败会抛出异常
 send（） 比transfer灵活，成功返回布尔值 表示是否成功   缺点：仅发送2300gas，失败不抛异常，需手动检查返回值
 call{value:amount}（“”）  可定义gsa量，支持复杂回调    缺点：存在重入风险，须严格遵循CEL模式或使用重入锁



三.阅读 UUPS、透明代理源码

四.使用hardhat V3开发任务3
